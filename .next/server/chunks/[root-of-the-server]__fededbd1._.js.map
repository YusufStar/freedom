{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 166, "column": 0}, "map": {"version":3,"sources":["file:///Users/yusufstar/Desktop/freedom/src/lib/account.ts"],"sourcesContent":["import axios from \"axios\";\nimport type { EmailMessage, SyncResponse, SyncUpdatedResponse } from \"./types\";\n\nexport class Account {\n    private token: string;\n\n    constructor(token: string) {\n        this.token = token;\n    }\n\n    private async startSync() {\n        const response = await axios.post<SyncResponse>(`https://api.aurinko.io/v1/email/sync`, {}, {\n            headers: {\n                Authorization: `Bearer ${this.token}`,\n            },\n            params: {\n                daysWithin: 2,\n                bodyType: 'html'\n            }\n        })\n\n        return response.data;\n    }\n\n    async getUpdatedEmails({ deltaToken, pageToken }: { deltaToken?: string, pageToken?: string }) {\n        let params: Record<string, string> = {}\n        if (deltaToken) params.deltaToken = deltaToken\n        if (pageToken) params.pageToken = pageToken\n\n        const response = await axios.get<SyncUpdatedResponse>(\"https://api.aurinko.io/v1/email/sync/updated\", {\n            headers: {\n                Authorization: `Bearer ${this.token}`,\n            },\n            params\n        })\n\n        return response.data;\n    }\n\n    async performInitialSync() {\n        try {\n            let syncResponse = await this.startSync()\n            while (!syncResponse.ready) {\n                await new Promise(resolve => setTimeout(resolve, 1000))\n                syncResponse = await this.startSync()\n            }\n\n            let storedDeltaToken: string = syncResponse.syncUpdatedToken;\n\n            let updatedResponse = await this.getUpdatedEmails({\n                deltaToken: storedDeltaToken\n            })\n\n            if (updatedResponse.nextDeltaToken) {\n                storedDeltaToken = updatedResponse.nextDeltaToken;\n            }\n\n            let allEmails: EmailMessage[] = updatedResponse.records;\n\n            while (updatedResponse.nextPageToken) {\n                updatedResponse = await this.getUpdatedEmails({pageToken: updatedResponse.nextPageToken});\n                allEmails = allEmails.concat(updatedResponse.records);\n                if (updatedResponse.nextDeltaToken) {\n                    storedDeltaToken = updatedResponse.nextDeltaToken\n                }\n            }\n\n            console.log('initial sync completed, we have synced', allEmails.length, 'emails')\n\n            return {\n                emails: allEmails,\n                deltaToken: storedDeltaToken\n            }\n        } catch (error) {\n            if (axios.isAxiosError(error)) {\n                console.log('Error during sync:', JSON.stringify(error.response?.data, null, 2))\n            } else {\n                console.error(\"Failed to perform initial sync\", error)\n            }\n\n            // throw error\n        }\n    }\n}"],"names":[],"mappings":";;;AAAA;;AAGO,MAAM;IACD,MAAc;IAEtB,YAAY,KAAa,CAAE;QACvB,IAAI,CAAC,KAAK,GAAG;IACjB;IAEA,MAAc,YAAY;QACtB,MAAM,WAAW,MAAM,uIAAA,CAAA,UAAK,CAAC,IAAI,CAAe,CAAC,oCAAoC,CAAC,EAAE,CAAC,GAAG;YACxF,SAAS;gBACL,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,EAAE;YACzC;YACA,QAAQ;gBACJ,YAAY;gBACZ,UAAU;YACd;QACJ;QAEA,OAAO,SAAS,IAAI;IACxB;IAEA,MAAM,iBAAiB,EAAE,UAAU,EAAE,SAAS,EAA+C,EAAE;QAC3F,IAAI,SAAiC,CAAC;QACtC,IAAI,YAAY,OAAO,UAAU,GAAG;QACpC,IAAI,WAAW,OAAO,SAAS,GAAG;QAElC,MAAM,WAAW,MAAM,uIAAA,CAAA,UAAK,CAAC,GAAG,CAAsB,gDAAgD;YAClG,SAAS;gBACL,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,EAAE;YACzC;YACA;QACJ;QAEA,OAAO,SAAS,IAAI;IACxB;IAEA,MAAM,qBAAqB;QACvB,IAAI;YACA,IAAI,eAAe,MAAM,IAAI,CAAC,SAAS;YACvC,MAAO,CAAC,aAAa,KAAK,CAAE;gBACxB,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS;gBACjD,eAAe,MAAM,IAAI,CAAC,SAAS;YACvC;YAEA,IAAI,mBAA2B,aAAa,gBAAgB;YAE5D,IAAI,kBAAkB,MAAM,IAAI,CAAC,gBAAgB,CAAC;gBAC9C,YAAY;YAChB;YAEA,IAAI,gBAAgB,cAAc,EAAE;gBAChC,mBAAmB,gBAAgB,cAAc;YACrD;YAEA,IAAI,YAA4B,gBAAgB,OAAO;YAEvD,MAAO,gBAAgB,aAAa,CAAE;gBAClC,kBAAkB,MAAM,IAAI,CAAC,gBAAgB,CAAC;oBAAC,WAAW,gBAAgB,aAAa;gBAAA;gBACvF,YAAY,UAAU,MAAM,CAAC,gBAAgB,OAAO;gBACpD,IAAI,gBAAgB,cAAc,EAAE;oBAChC,mBAAmB,gBAAgB,cAAc;gBACrD;YACJ;YAEA,QAAQ,GAAG,CAAC,0CAA0C,UAAU,MAAM,EAAE;YAExE,OAAO;gBACH,QAAQ;gBACR,YAAY;YAChB;QACJ,EAAE,OAAO,OAAO;YACZ,IAAI,uIAAA,CAAA,UAAK,CAAC,YAAY,CAAC,QAAQ;gBAC3B,QAAQ,GAAG,CAAC,sBAAsB,KAAK,SAAS,CAAC,MAAM,QAAQ,EAAE,MAAM,MAAM;YACjF,OAAO;gBACH,QAAQ,KAAK,CAAC,kCAAkC;YACpD;QAEA,cAAc;QAClB;IACJ;AACJ","debugId":null}},
    {"offset": {"line": 253, "column": 0}, "map": {"version":3,"sources":["file:///Users/yusufstar/Desktop/freedom/src/env.js"],"sourcesContent":["import { createEnv } from \"@t3-oss/env-nextjs\";\nimport { z } from \"zod\";\n\nexport const env = createEnv({\n  /**\n   * Specify your server-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars.\n   */\n  server: {\n    DATABASE_URL: z.string().url(),\n    NODE_ENV: z\n      .enum([\"development\", \"test\", \"production\"])\n      .default(\"development\"),\n  },\n\n  /**\n   * Specify your client-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars. To expose them to the client, prefix them with\n   * `NEXT_PUBLIC_`.\n   */\n  client: {\n    // NEXT_PUBLIC_CLIENTVAR: z.string(),\n  },\n\n  /**\n   * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.\n   * middlewares) or client-side so we need to destruct manually.\n   */\n  runtimeEnv: {\n    DATABASE_URL: process.env.DATABASE_URL,\n    NODE_ENV: process.env.NODE_ENV,\n    // NEXT_PUBLIC_CLIENTVAR: process.env.NEXT_PUBLIC_CLIENTVAR,\n  },\n  /**\n   * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially\n   * useful for Docker builds.\n   */\n  skipValidation: !!process.env.SKIP_ENV_VALIDATION,\n  /**\n   * Makes it so that empty strings are treated as undefined. `SOME_VAR: z.string()` and\n   * `SOME_VAR=''` will throw an error.\n   */\n  emptyStringAsUndefined: true,\n});\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,MAAM,MAAM,CAAA,GAAA,+JAAA,CAAA,YAAS,AAAD,EAAE;IAC3B;;;GAGC,GACD,QAAQ;QACN,cAAc,oKAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG;QAC5B,UAAU,oKAAA,CAAA,IAAC,CACR,IAAI,CAAC;YAAC;YAAe;YAAQ;SAAa,EAC1C,OAAO,CAAC;IACb;IAEA;;;;GAIC,GACD,QAAQ;IAER;IAEA;;;GAGC,GACD,YAAY;QACV,cAAc,QAAQ,GAAG,CAAC,YAAY;QACtC,QAAQ;IAEV;IACA;;;GAGC,GACD,gBAAgB,CAAC,CAAC,QAAQ,GAAG,CAAC,mBAAmB;IACjD;;;GAGC,GACD,wBAAwB;AAC1B","debugId":null}},
    {"offset": {"line": 300, "column": 0}, "map": {"version":3,"sources":["file:///Users/yusufstar/Desktop/freedom/src/server/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nimport { env } from \"~/env\";\n\nconst createPrismaClient = () =>\n  new PrismaClient({\n    log:\n      env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  });\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: ReturnType<typeof createPrismaClient> | undefined;\n};\n\nexport const db = globalForPrisma.prisma ?? createPrismaClient();\n\nif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = db;\n"],"names":[],"mappings":";;;AAAA;AAEA;;;AAEA,MAAM,qBAAqB,IACzB,IAAI,6HAAA,CAAA,eAAY,CAAC;QACf,KACE,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,gBAAgB;YAAC;YAAS;YAAS;SAAO,GAAG;YAAC;SAAQ;IAC3E;AAEF,MAAM,kBAAkB;AAIjB,MAAM,KAAK,gBAAgB,MAAM,IAAI;AAE5C,IAAI,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,cAAc,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 325, "column": 0}, "map": {"version":3,"sources":["file:///Users/yusufstar/Desktop/freedom/src/app/api/initial-sync/route.ts"],"sourcesContent":["import { NextResponse, type NextRequest } from \"next/server\";\nimport { Account } from \"~/lib/account\";\nimport { db } from \"~/server/db\";\n\nexport const POST = async (req: NextRequest) => {\n    const { accountId, userId } = await req.json();\n    if (!accountId || !userId) return NextResponse.json({ error: \"Missing accountId or userId\" }, { status: 400 });\n\n    const dbAccount = await db.account.findUnique({\n        where: {\n            id: accountId,\n            userId\n        }\n    })\n\n    if (!dbAccount) return NextResponse.json({ error: \"Account not found\" }, { status: 404 });\n\n    const account = new Account(dbAccount.accessToken)\n    const response = await account.performInitialSync()\n    if (!response) {\n        return NextResponse.json({ error: \"Failed to perform initial sync\" }, { status: 500 })\n    }\n\n    const {emails, deltaToken} = response;\n    console.log(\"emails\", emails)\n\n    // await db.account.update({\n    //     where: {\n    //         id: accountId,\n    //     },\n    //     data: {\n    //         nextDeltaToken: deltaToken\n    //     }\n    // })\n\n    // await syncEmailsDatabase(emails)\n\n    console.log(\"sync completed\", deltaToken)\n    return NextResponse.json({ success: true }, { status: 200 })\n}"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAEO,MAAM,OAAO,OAAO;IACvB,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,GAAG,MAAM,IAAI,IAAI;IAC5C,IAAI,CAAC,aAAa,CAAC,QAAQ,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;QAAE,OAAO;IAA8B,GAAG;QAAE,QAAQ;IAAI;IAE5G,MAAM,YAAY,MAAM,qHAAA,CAAA,KAAE,CAAC,OAAO,CAAC,UAAU,CAAC;QAC1C,OAAO;YACH,IAAI;YACJ;QACJ;IACJ;IAEA,IAAI,CAAC,WAAW,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;QAAE,OAAO;IAAoB,GAAG;QAAE,QAAQ;IAAI;IAEvF,MAAM,UAAU,IAAI,uHAAA,CAAA,UAAO,CAAC,UAAU,WAAW;IACjD,MAAM,WAAW,MAAM,QAAQ,kBAAkB;IACjD,IAAI,CAAC,UAAU;QACX,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAiC,GAAG;YAAE,QAAQ;QAAI;IACxF;IAEA,MAAM,EAAC,MAAM,EAAE,UAAU,EAAC,GAAG;IAC7B,QAAQ,GAAG,CAAC,UAAU;IAEtB,4BAA4B;IAC5B,eAAe;IACf,yBAAyB;IACzB,SAAS;IACT,cAAc;IACd,qCAAqC;IACrC,QAAQ;IACR,KAAK;IAEL,mCAAmC;IAEnC,QAAQ,GAAG,CAAC,kBAAkB;IAC9B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;QAAE,SAAS;IAAK,GAAG;QAAE,QAAQ;IAAI;AAC9D","debugId":null}}]
}